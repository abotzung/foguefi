#!/bin/bash
#
# @category FOGStubmenu
# @package  FOGUefi
# @author   Alexandre Botzung <alexandre.botzung@grandest.fr>
# @license  http://opensource.org/licenses/gpl-3.0 GPLv3
# @link     https://fogproject.org
#
# S98_menuFogGUI
# Menu de démarrage alternatif pour FOG stub (version 1.5.9+)
#   Permets de démarrer FOG stub avec Secure Boot activée.
# NOTE: Initialement, ce n'était qu'un hack perso.
#
# Nouvelles variables (programmable au bootcmd): 

# Compte de connexion : 
# Nom d'utilisateur : FOG_username=foo
# Mot de passe (en clair...) : FOG_password=bar
#
# Auto multicast : 
# Programmation de la tâche multicast : FOG_multicastSessionName=toto123456
#
# Téléchargement auto d'une image :
# Programmation de la tâche download : FOG_imageID=42



# Exemple : 
# -----> Pour automatiquement joindre un session multicast avec le nom pc_compta : 
#
# Démarrer le kernel avec les paramètres suivants : 
#  root=/dev/ram0 rw ramdisk_size=275000 consoleblank=0 nvme_core.default_ps_max_latency_us=0 \
#    nomodeset keymap=fr
#    web=http://<IP DE VOTRE SERVEUR FOG>/fog storage=<IP DE VOTRE SERVEUR FOG/STORAGE>:/images/ \
#    storageip=<IP DE VOTRE SERVEUR FOG/STORAGE> \
#    menutype=askmc FOG_username=<COMPTE EXISTANT SUR LE SERVEUR FOG> FOG_password=<Mot de passe> \
#    FOG_multicastSessionName=pc_compta
#
# -----> Pour automatiquement télécharger l'image ID 42 : 
#
# Démarrer le kernel avec les paramètres suivants : 
#  root=/dev/ram0 rw ramdisk_size=275000 consoleblank=0 nvme_core.default_ps_max_latency_us=0 \
#    nomodeset keymap=fr
#    web=http://<IP DE VOTRE SERVEUR FOG>/fog storage=<IP DE VOTRE SERVEUR FOG/STORAGE>:/images/ \
#    storageip=<IP DE VOTRE SERVEUR FOG/STORAGE> \
#    menutype=down dologin=yes \
#    FOG_username=<COMPTE EXISTANT SUR LE SERVEUR FOG> FOG_password=<Mot de passe> \
#    FOG_imageID=42

# Source les fonctions internes de FOG
. /usr/share/fog/lib/funcs.sh

getIPAddresses() {
    read ipaddr <<< $(/sbin/ip -4 -o addr | awk -F'([ /])+' '/global/ {print $4}' | tr '[:space:]' '|' | sed -e 's/^[|]//g' -e 's/[|]$//g')
    echo $ipaddr
}

init_backtitle() {
    # Initialise la backtitle par défaut
    if [[ -z "$defautboottype" ]]; then
        defautboottype='Legacy'
        [[ -n $(dmesg | grep "Secure boot disabled") ]] && defautboottype='UEFI'
        [[ -n $(dmesg | grep "Secure boot enabled") ]] && defautboottype='UEFI Secure boot'
    fi
        
    if [[ -z $(cat /proc/cmdline | grep 'FOG_rebranding_banner=') ]]; then
        # La bannière n'a PAS été forcée depuis la CMD ? On remets la 'legacy' en place !
        FOG_rebranding_banner='Alexandre BOTZUNG (alexandre.botzung@grandest.fr)'
    fi
    if [[ -z $(cat /proc/cmdline | grep 'FOG_rebranding_software=') ]]; then
        # La bannière n'a PAS été forcée depuis la CMD ? On remets la 'legacy' en place !
        fog_compName
        #FOG_rebranding_software="FOG Stub [$defautboottype] $initversion - $FOG_rebranding_banner [$FOGcomputerName]"
        IPClient=$(getIPAddresses)
        FOG_rebranding_software="FOGUefi Stub [$IPClient] $initversion - $FOG_rebranding_banner [$FOGcomputerName]"
        #FOG_rebranding_software="FOGUefi system console [$IPClient] $initversion - $FOG_rebranding_banner [$FOGcomputerName]"
    fi
}

login_fog () {
    # La procédure renvoie 0 si la connexion est réussie, 1 sinon.
    #
    # $FOG_username et $FOG_password sont peuplés si le code de retour = 0, les variables sont vidés sinon.
    # $FOG_rebranding_banner peut être utilisée pour changer bannière de connexion.
    #
    # Utilise le nouveau "grubbootmenu.class.php"
    # /!\ Here be Dragons /!\
    #
    # Alex 03072022 : Un timeout a été ajoutée au popups de connexion, permettant une execution non bloquante en cas de remastérisation "inattendue"

    if [[ "$FOG_islogged" == "1" ]]; then # Est-on déjà connecté ? Si oui, pas la peine de refaire une demande d'auth.
        return 0
    fi
    weblogin=''
    webpass=''

    weblogin=$FOG_username
    webpass=$FOG_password    
    FOG_islogged=0 # Drapeau indiquant si l'on est correctement connecté au serveur FOG
    
    MONuuid=$(dmidecode -s system-uuid)
    MONuuid=${sysuuid,,}
    MONmac=$(getMACAddresses)
    
    while true; do
        if [[ -n "$weblogin" && -n "$webpass" ]]; then
            # Si on a déjà le login et le mot de passe, j'essaye une authentification
            # Cela permettera d'automatiser des connexions via le boot par clé usb ("FOG Self-Service")
            #DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&username=${weblogin}&password=${webpass}" "${web}service/grub/grub.php" -A '')

            _templogin=$(echo $weblogin | tr -d '\012' | base64)
            _temppass=$(echo $webpass | tr -d '\012' | base64)
            DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&username=${_templogin}&password=${_temppass}" "${web}service/checkcredentials.php" -A '')
            _templogin=''
            _temppass=''


            ### Mot de passe incorrect : 
            if [[ $DoCurl == *"#!ok"* ]]; then
                FOG_username=$weblogin
                FOG_password=$webpass
                weblogin=''
                webpass=''
                FOG_islogged=1
                return 0
            fi
            
            # Compte incorrect, détruit les variables en mémoire

            FOG_username=''
            FOG_password=''
            FOG_islogged=0
            
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --timeout $FOG_DialogTimeout \
                --ok-label "OK" \
                --msgbox "The username or password is incorrect." 6 47
            export DIALOGRC=
        fi

	export DIALOGRC=''
	#export DIALOGRC="/root/dialog_jaune"
        BoiteDeDialogue="dialog \
        --backtitle \"$FOG_rebranding_software\" \
        --title \"Login to FOG\" 
        --insecure \
        --timeout $FOG_DialogTimeout \
        --cancel-label \"Cancel\" \
        --mixedform \
        \"Enter your FOG credential :\" 10 53 0 \
        \"Username: \" 1 1 \"\" 1 20 27 64 0 \
        \"Password:\"  2 1 \"\" 2 20 27 64 1"

        exec 3>&1
        selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
        exit_status=$?
        exec 3>&-
        if [[ $exit_status != "0" ]]; then
            weblogin=''
            webpass=''
            FOG_username=''
            FOG_password=''
            FOG_islogged=0
            return 1
        fi

        IFS=$'\n'
        COMPTE=($selection)

        weblogin="${COMPTE[0]}"
        webpass="${COMPTE[1]}"

        if [[ -z "$webpass" ]]; then
	    #export DIALOGRC="/root/dialog_jaune"
            BoiteDeDialogue="dialog \
            --backtitle \"$FOG_rebranding_software\" \
            --title \"Login to FOG\" 
            --insecure \
            --timeout $FOG_DialogTimeout \
            --cancel-label \"Cancel\" \
            --mixedform \
            \"Enter your password :\" 10 53 0 \
            \"Password:\"  1 1 \"\" 1 20 27 64 1"

            exec 3>&1
            selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
            exit_status=$?
            exec 3>&-
            if [[ $exit_status != "0" ]]; then
                weblogin=''
                webpass=''
                FOG_username=''
                FOG_password=''
                FOG_islogged=0
                return 1
            fi

            IFS=$'\n'
            COMPTE=($selection)

            webpass="${COMPTE[0]}"
        fi
    done
}

login_or_reboot () {
    # On doit être loguée, force une connexion . . .
    fog_compName            # Récupère le nom enregistrée de la machine
    login_fog                # Tente une connexion. Si FOG_username && FOG_password sont déjà peuplés, tente une connexion silencieuse.
    retval=$?
    verifTaches                # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 1 ]]; then
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi
    if [[ $retval == 1 ]]; then
        do_exit
    fi
}

verifTaches () {
    # Vérifie toujours les tâches en cours, sauf si la variable osid est déjà peuplée.
    #if [[ $boottype == usb && ! -z $web ]]; then
    if [[ -z $osid ]]; then
        MONuuid=$(dmidecode -s system-uuid)
        MONuuid=${sysuuid,,}
        MONmac=$(getMACAddresses)
        sysuuid='' # Patch pour l'export qui échoue dans certaines conditions
        mac=''
        export sysuuid="$MONuuid"
        #sysuuid=$MONuuid
        export mac="$MONmac"
        #mac=$MONmac
        curl -Lks -o /tmp/hinfo.txt --data "sysuuid=${MONuuid}&mac=$MONmac" "${web}service/hostinfo.php" -A ''
        
        # Valide le fichier hinfo
        dummy=$(cat /tmp/hinfo.txt | grep export)
        if [[ "$dummy" != *"export"* ]]; then
            rm /tmp/hinfo.txt
        fi
        # Valide le fichier krnl
        if [[ -f /tmp/krnl.txt ]]; then
            dummy=$(cat /tmp/krnl.txt | grep export)
            if [[ "$dummy" != *"export"* ]]; then
                rm /tmp/krnl.txt
            fi    
        fi
        [[ -f /tmp/hinfo.txt ]] && . /tmp/hinfo.txt
        [[ -f /tmp/krnl.txt ]] && . /tmp/krnl.txt
    fi

    # TABLE DE VERITEE :
    # $type        $mode        $osid            $FLAG
    #
    #  xxx       -               -              non 
    #   -         xxx          -               OUI (tache locale) 
    #   -        -           xxx             non
    #  xxx       -           xxx              OUI (tache serveur ou programmée)
    #  xxx       xxx         xxx              OUI (tache serveur ou programmée spéciale)
    #

    if [[ -n $type && -n $osid ]]; then
        # Si $type est définie {up/down} && que $osid est définie (peut importe $mode), il y a quelque-chose à faire
        #echo "Tache programmée (SERVEUR/PROGRAMMEE)"
        return 1 # 1 = Tache programmée
    fi
    
    if [[ -z $type && -n $mode ]]; then
        # Si $mode est définie {clamav, manreg...} && que $type n'est pas définie, il y a un mode à traîter
        #echo "Tache programmée (MODE)"
        return 1 # 1 = Tache programmée
    fi
    
    return 0
}

fog_compName () {
    ######## Donne le nom du pc à l'aide du serveur FOG ####
    # Renvoie ***Unknown*** si l'ordinateur n'existe pas
    MONuuid=$(dmidecode -s system-uuid)
    MONuuid=${sysuuid,,}
    MONmac=$(getMACAddresses)
    DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac" "${web}service/hostname.php" -A '')

    if [[ $DoCurl == *"#!ok="* ]]; then
        IFS=$'\n'
        for line in $DoCurl; do
            if [[ $line == *"#!ok="* ]]; then
                line2=$(echo "$line" | sed -r 's,\t,,g')
                line2=${line2/=/|}
                FOGcomputerName=$(awk -F\|  '{print $2}' <<< $line2)
            fi
        done
    else
        FOGcomputerName="***Unknown***"
    fi
}

do_fog () {
    # Ce process simule l'opération de FOG, pour une tâche détecté (programmée alors que le STUB était déjà lancée.)
    # Comme les variable sont normalement définies au moment du boot, je ne peut pas laisser le script se dérouler 
    #    (à cause du contexte des exports, détruit si l'on quitte l'exécution de ce fichier.)
    # ICI, je récupère les variables (hinfo + krnl) et je lance FOG.
    # On ne quitte (normalement) jamais cette routine.
    
    # Destruction des modes / types (sachant qu'on va de toute façon les récupérer)
    export -n mode
    export -n type
    
    # Je vérifie si j'ai une tâche en attente. Je charge hinfo.txt && krnl.txt
    verifTaches    
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 0 ]]; then
        # Etrange ; on a pas de tâche programmée. Je quitte la routine. 
        return 1
    fi
    # Il existe une tâche FOG, détruit les creds par mesure de sécurité.
    FOG_islogged=0
    FOG_username=''
    FOG_password=''
    weblogin=''
    webpass=''
    
    if [[ -n "$mode" || -n "$type" ]]; then
        # Une tâche "sur le pouce est programmée. Je prend le rôle de FOG (pour le passage des exports)
        
        if [[ $relaunchFog == 2 ]]; then #Si l'on relance FOG
            if [[ "$mode" == *"reg"* ]]; then # Et que la tâche actuelle est toujours *reg*
                return 0 # C'est que l'on a rien d'autre à faire.
            fi
        fi

        # Il y a peut-être une tâche type "down" ochestrée par le serveur. Je relance do_fog après fog() pour 
        if [[ -n "$mode" ]]; then
            if [[ "$mode" == *"reg"* ]]; then
                relaunchFog=$((relaunchFog=relaunchFog+1))
            fi
        fi
        # ---------------------
        
        
        [[ ! -h /dev/fd ]] && ln -s /proc/self/fd /dev/fd
        [[ ! -h /dev/stdin ]] && ln -s /proc/self/fd/0 /dev/stdin
        [[ ! -h /dev/stdout ]] && ln -s /proc/self/fd/1 /dev/stdout
        [[ ! -h /dev/stderr ]] && ln -s /proc/self/fd/2 /dev/stderr
        if [[ $mdraid == true ]]; then
            mdadm --auto-detect
            mdadm --assemble --scan
            mdadm --incremental --run --scan
        fi    
        case $isdebug in
            [Yy][Ee][Ss]|[Yy])
                fog.debug
                ;;
            *)
                fog
                if [[ $relaunchFog == 1 ]]; then
                    # Tâche manreg/autoreg détectée, je relance do_fog. hinfo.txt sera peuplée du down. (si présent)
                    relaunchFog=2
                    # Détruit la tâche actuelle pour accueillir la nouvelle tâche
                    mode=''
                    export -n mode
                    type=''
                    export -n type
                    do_fog
                fi
                do_exit
                ;;
        esac
    fi
}

do_exit() {
    # Quitte le FOG Stub / debug
    case $isdebug in
        [Yy][Ee][Ss]|[Yy])
            echo 'Welcome to debug shell'
            echo 'Type "exit" to reboot.'
            /bin/bash
            ;;
        *)
            if [[ -f '/tmp/chroot_started' ]]; then
                # On est dans Xorg ( dans le chroot )? Tue dtach et ferme le socket afin de baisser le sémaphore. "Fog has finished"
                killall dtach
                rm -f /run/dtach/terminal_ready
                while (true) # Comme on est dans Xorg, c'est cette partie qui est responsable de la gestion de l'arrêt/redémarrage du système
                do
                    sleep 1
                done
            fi
            ;;
    esac
    sync
    killall framebuffer-vncserver
    [[ $shutdown -eq 1 ]] && poweroff -f || reboot -f
}

hotpatch_fog() {
    # Alex 31/07/2022 : 
    # Tout mon projet autour du FOG n'a que été des ajouts. Aucune modification d'un fichier nécessaire à FOG a été réalisée.
    # <i> Et je me refuse à "toucher" à un fichier "primordial" de FOG. (car en cas de MaJ, la compatibilitée pourrait être cassée)</i>
    #
    # Hors pour que ce script fonctionne correctement (surtout fog{.*}), il est nécessaire de modifier le fichier /usr/share/fog/funcs.sh
    # Cette routine s'occupe d'ajouter ce patch "à chaud" afin de permettre à FOG de récupérer les bonnes variables 
    #   pendant son exécution.
    #
    # Je ne cache pas que "ça m'emmerde" profondément de devoir modifier les fichiers originaux du Project FOG, mais pas le choix...
    
    if [[ -z $FOG_hotpatch ]]; then
        # PATCH du fichier /usr/share/fog/funcs.sh
        rm /tmp/patch 2>/dev/null
        echo '#!/bin/bash'                                                         > /tmp/patch
        echo '#================================================================#' >> /tmp/patch
        echo '#================ This FILE has been HOTPATCHED =================#' >> /tmp/patch
        echo '#================================================================#' >> /tmp/patch
        echo "#== by : $(readlink -f $0) #"                                       >> /tmp/patch
        echo 'sysuuid=$(dmidecode -s system-uuid)'                                >> /tmp/patch
        echo 'sysuuid=${sysuuid,,}'                                               >> /tmp/patch
        echo 'if [[ -f /tmp/hinfo.txt ]]; then'                                   >> /tmp/patch
        echo '    dummy=$(cat /tmp/hinfo.txt | grep export)'                      >> /tmp/patch
        echo '    if [[ "$dummy" != *"export"* ]]; then'                          >> /tmp/patch
        echo '        rm /tmp/hinfo.txt'                                          >> /tmp/patch
        echo '    fi'                                                             >> /tmp/patch
        echo 'fi'                                                                 >> /tmp/patch
        echo 'if [[ -f /tmp/krnl.txt ]]; then'                                    >> /tmp/patch
        echo '    dummy=$(cat /tmp/krnl.txt | grep export)'                       >> /tmp/patch
        echo '    if [[ "$dummy" != *"export"* ]]; then'                          >> /tmp/patch
        echo '        rm /tmp/krnl.txt'                                           >> /tmp/patch
        echo '    fi'                                                             >> /tmp/patch
        echo 'fi'                                                                 >> /tmp/patch
        echo '[[ -f /tmp/hinfo.txt ]] && . /tmp/hinfo.txt'                        >> /tmp/patch
        echo '[[ -f /tmp/krnl.txt ]] && . /tmp/krnl.txt'                          >> /tmp/patch
        echo '#EOP================ E N D   O F   P A T C H =================EOP#' >> /tmp/patch

        cat /tmp/patch /usr/share/fog/lib/funcs.sh > /usr/share/fog/lib/funcs_patched.sh
        mv /usr/share/fog/lib/funcs.sh /usr/share/fog/lib/funcs.sh_ORIGINAL
        mv /usr/share/fog/lib/funcs_patched.sh /usr/share/fog/lib/funcs.sh
        chmod +x /usr/share/fog/lib/funcs.sh

        # PATCH du fichier /bin/fog.mount
        rm /tmp/patch 2>/dev/null
        echo '#!/bin/bash'                                                         > /tmp/patch
        echo '#================================================================#' >> /tmp/patch
        echo '#================ This FILE has been HOTPATCHED =================#' >> /tmp/patch
        echo '#================================================================#' >> /tmp/patch
        echo "#== by : $(readlink -f $0) #"                                       >> /tmp/patch
        echo 'CMDArgs_1=$1'                                                       >> /tmp/patch
        echo 'if [[ -n "$CMDArgs_1" ]]; then'                                     >> /tmp/patch
        echo '    if [[ "$CMDArgs_1" == "xserver" ]]; then'                       >> /tmp/patch
        echo '        export -n type'                                             >> /tmp/patch
        echo '        type="down"'                                                >> /tmp/patch
        echo "        storage=\$(printf '%s\n' \"\${storage//dev\//}\")"          >> /tmp/patch
        echo '    fi'                                                             >> /tmp/patch
        echo 'fi'                                                                 >> /tmp/patch
        echo '#EOP================ E N D   O F   P A T C H =================EOP#' >> /tmp/patch

        cat /tmp/patch /bin/fog.mount > /bin/fog_mount_patched.sh
        mv /bin/fog.mount /bin/fog.mount_ORIGINAL
        mv /bin/fog_mount_patched.sh /bin/fog.mount
        chmod +x /bin/fog.mount

        FOG_hotpatch='yes' # Marque le système comme "patchée".
    fi
}

PROCESS_SelectDownloadImage() {
    # Cette partie propose de choisir une image à remastériser. Elle crée elle-même la fausse tâche "false tasking".
    
    # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
    verifTaches                
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 1 ]]; then
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi

    # Est-on connecté à FOG ? Si non, -> LOGIN
    if [[ $FOG_islogged != 1 ]]; then
        login_fog
        retval=$?
        if [[ $retval == 1 ]]; then
            # Login échouée ? AU REVOIR ! 
            return 0
        fi
    fi
    
    image_id=0
    if [[ -n "$FOG_imageID" ]]; then
        #echo "FOG_imageID présent, je fait la vérif..."
        
        # On a déjà une image dans la ligne de commande. 
        #  je vérifie qu'elle est valide. Si non, j'efface la variable.
        DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&qihost=1&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')
        
        i=0
        export DIALOGRC=
        if [[ "$DoCurl" != *'***!IMAGE-HEADER!***'* ]]; then # Problème générale
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --timeout $FOG_DialogTimeout \
                --msgbox "Host is not valid, host has no image assigned, or there are no images defined on the server.", 6 45
            export DIALOGRC=
            return 1
        fi
        if [[ "$DoCurl" != *"imgitem"* ]]; then # Aucune image trouvée
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --timeout $FOG_DialogTimeout \
                --msgbox "There are no images defined on the server.", 6 45
            export DIALOGRC=
            return 1
        fi        
        
        # 2. Je découpe les lignes en tableau pour le script
        # https://stackoverflow.com/questions/7103531/how-to-get-the-part-of-a-file-after-the-first-line-that-matches-a-regular-expres
        # https://stackoverflow.com/questions/37173774/how-to-read-columns-from-csv-file-into-array-in-bash
        IFS=''
        imageItem=()
        imagePath=()
        imageName=()
        imageID=()
        array=()
        
        while IFS=',' read -ra array; do
            imageItem+=("${array[0]}")
            imagePath+=("${array[1]}")
            imageName+=("${array[2]}")
            imageID+=("ID# ${array[3]}")
        done <<< "$(echo $DoCurl | sed -e '1d')"

        # imageItem = {imgitem / imgdefault}
        imageParDefault_ID='0'
        for arrayIndex in "${!imageID[@]}"; do
            FOG_imageID_temp=$(echo "${imageID[$arrayIndex]}" | sed -r 's/[^0-9]*//g')
            if [[ "$FOG_imageID_temp" == "$FOG_imageID" ]]; then
                # On a une correspondance d'image ? Cool ! 
                image_id="$FOG_imageID"
                image_id=$(echo "$image_id" | sed -r 's/[^0-9]*//g')
            fi
        done
        if [[ "$image_id" == 0 ]]; then
            # On a pas trouvé l'image dans la BDD FOG, on efface le terme pour afficher le menu
            unset image_id
            unset FOG_imageID
        fi
    fi

    if [[ -z "$FOG_imageID" ]]; then
        # ~~~~~~~~~~~~~~~~~~ LISTING DES IMAGES DU SERVEUR ~~~~~~~~~~~~~~~~
        # 1. Je récupère la liste des images du serveurs (via grub.php)
        
        DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&qihost=1&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')
        
        i=0
        if [[ "$DoCurl" != *'***!IMAGE-HEADER!***'* ]]; then
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --timeout $FOG_DialogTimeout \
                --msgbox "Host is not valid, host has no image assigned, or there are no images defined on the server.'," 6 45
            export DIALOGRC=
            return 1
        fi

        if [[ "$DoCurl" != *"imgitem"* ]]; then # Aucune image trouvée
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --timeout $FOG_DialogTimeout \
                --msgbox "There are no images defined on the server.'," 6 45
            export DIALOGRC=
            return 1
        fi        

        # 2. Je découpe les lignes en tableau pour le script
        # https://stackoverflow.com/questions/7103531/how-to-get-the-part-of-a-file-after-the-first-line-that-matches-a-regular-expres
        # https://stackoverflow.com/questions/37173774/how-to-read-columns-from-csv-file-into-array-in-bash
        IFS=''
        imageItem=()
        imagePath=()
        imageName=()
        imageID=()
        array=()
        
        while IFS=',' read -ra array; do
            imageItem+=("${array[0]}")
            imagePath+=("${array[1]}")
            imageName+=("${array[2]}")
            imageID+=("ID# ${array[3]}")
        done <<< "$(echo $DoCurl | sed -e '1d')"

        # imageItem = {imgitem / imgdefault}
        imageParDefault_ID='0'
        for arrayIndex in "${!imageItem[@]}"; do
            if [[ "${imageItem[$arrayIndex]}" == "imgdefault" ]]; then
                # On a une image par défaut ? COOL!
                imageParDefault_ID="${imageID[$arrayIndex]}"
                imageParDefault_NOM="${imageName[$arrayIndex]}"
            fi
        done

        LeTas=''
        if [[ "$imageParDefault_ID" == '0' ]]; then
            # Pas d'image par défaut, je fait le listing de base
            
            for arrayIndex in "${!imageItem[@]}"; do                                                # Scanne le tableau....
                if [[ "${imageItem[$arrayIndex]}" == "imgitem" ]]; then                            # à la recherche de "imgitem"....
                    LeTas="${LeTas}\"${imageID[$arrayIndex]}\" \"${imageName[$arrayIndex]}\" "  # On trouve des trucs ? Ajoute les sur le tas !
                fi
            done
        else
            # Une image est par défaut, je l'ajoute en priorité sur le tas
            LeTas="${LeTas}\"${imageParDefault_ID}\" \"* ${imageParDefault_NOM}\" "                    # Définis l'image par défaut
            for arrayIndex in "${!imageItem[@]}"; do                                                    # Scanne le tableau....
                if [[ "${imageItem[$arrayIndex]}" == "imgitem" ]]; then                                # à la recherche de "imgitem"....
                    if [[ "${imageID[$arrayIndex]}" != "$imageParDefault_ID" ]]; then                # AYANT un autre ID que l'image par défaut.
                        LeTas="${LeTas}\"${imageID[$arrayIndex]}\" \"${imageName[$arrayIndex]}\" "    # On trouve des trucs ? Ajoute les sur le tas !
                    fi
                fi
            done        
        fi

        IFS=''
        BoiteDeDialogue="dialog \
        --backtitle \"$FOG_rebranding_software\" \
        --title \"List of available images :\" \
        --clear \
        --timeout $FOG_DialogTimeout \
        --menu \"\" 15 53 9 \
        $LeTas"
        exec 3>&1
        selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
        exit_status=$?
        exec 3>&-
        if [[ $exit_status != "0" ]]; then
            return 0 
        fi
        image_id=$(echo "$selection" | sed -r 's/[^0-9]*//g')
    fi

    # ICI, on est censé avoir l'ID de l'image que l'on va remastériser. On lance une programmation pour avoir une "false-tasking".
    # Phase 3 ; programmation de l'image

    DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&qihost=1&imageID=$image_id&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')

    verifTaches
    verifTachesFLAG=$?

    # OLD: param menuAccess 1 (si PC enregistrée)

    if [[ $FOGcomputerName != "***Unknown***" && $verifTachesFLAG == "0" ]]; then
        export DIALOGRC="/root/dialog_rouge"
        dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "!!! FATAL INTERNAL ERROR !!!" \
            --ok-label "Ok" \
            --timeout $FOG_DialogTimeout \
            --msgbox "An error occurred during the programming of the image deployment. I can't continue. -> $DoCurl" 7 47
        export DIALOGRC=
        return 0
    fi
    if [[ $FOGcomputerName == "***Unknown***" ]]; then
        # PC *PAS PRESENT* dans Fog, je dois parser les lignes pour les refiler à FOG
        
        # PASSE 1 : Récupère les infos du kernel (linuxefi ...)
        IFS=$'\n'
        for line in $DoCurl; do
            if [[ $line == "linuxefi "* ]]; then
                ligneKRNL=$line
            fi
        done
        if [[ $ligneKRNL != "linuxefi "* ]]; then
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "!!! FATAL INTERNAL ERROR !!!" \
                --ok-label "Oh no !" \
                --timeout $FOG_DialogTimeout \
                --msgbox "I cant find the string 'linuxefi' ; I can't go on. [PROCESS_SelectDownloadImage -> PCUnknown -> $DoCurl ]" 7 47
            export DIALOGRC=
            return 0
        fi
        
        # PASSE 2 : Découpe les args du kernel en infos pertinentes pour FOG
        IFS=" "
        [[ -f /tmp/krnl.txt ]] && rm /tmp/krnl.txt
        for line in $ligneKRNL; do
            if [[ $line == *"="* ]]; then
                cle=$(awk -F'='  '{print $1}' <<< $line)
                valeur=$(awk -F'='  '{print $2}' <<< $line)
                echo "[[ -z \$$cle ]] && export $cle='$valeur'" >> /tmp/krnl.txt
            fi
        done    
        
        # Patch ridicule pour sortir les variables en EXPORT.
        # Mais cela ne fonctionne pas, car ce script (enfant) de S98MenuFog (parent) ne peut pas modifier l'environnement des parents. 
        # Donc les parents DOIVENT CHARGER les exports et si ils sont peuplés, la seulement lancer fog. (selon debug/NotDebug)
        [[ -f /tmp/krnl.txt ]] && . /tmp/krnl.txt >/dev/null 2>&1

    fi
    
    do_fog # Part du principe qu'une tâche est attendue. Dans le cas contraire, on quitte la routine.
}

PROCESS_Memtest() {
    #Malheuresement, Memtest86+ (5.0+) est désormais dans une licence propriétaire.
    # Il existe une solution de repli à l'aide de l'utilitaire memtester (présent aussi dans Clonezilla).

    # Une partie du code ci-dessous à été réalisée par Steven Shiau <steven _at_ clonezilla org>
    # License: GPL 
    
    if [[ -z "${memtest_testrounds}" ]]; then
        #Par défaut, fait 10 tests de la mémoire vive.
        memtest_testrounds=10
    fi
    
    echo "Free and used memory in the system (Mbytes):"
    echo "***********"
    free -m
    echo "***********"
    if [ -n "$mem_size" ]; then
      avail_mem_MB="$mem_size"
    else
      avail_mem_MB="$(LC_ALL=C free -m | grep -i "^Mem:" | awk -F" " '{print $NF}')"
    fi
    run_cmd="memtester ${avail_mem_MB}M $memtest_testrounds"
    echo "Run: $run_cmd"
    eval $run_cmd
    rc=$?
    if [ "$rc" -eq 1 ]; then
      echo "Everything works properly about the memory in this system."
      # Un délai est ajoutée pour rebooter en cas de réussite.
      read -t $FOG_DialogTimeout -p "Press [enter] to reboot . . . "
      return 0
    fi
    displayBanner
    echo "========================================================"
    echo "========= A MEMORY FAILURE HAS BEEN DETECTED ! ========="
    echo "========================================================"
    # Pas de délai pour une mémoire défaillante.
    read -p "Press [enter] to reboot . . . "
    return 1
}

PROCESS_XOrg() {
    # Passe en mode graphique ICI
    # - Ne reviens JAMAIS de cette routine. -
    # Car : flemme de gérer un orchestrateur de tâches lançant soit Xorg+Xterm avec dtach / soit dtach seul.
    #       && surtout qu'il n'est pas possible de quitter une session dtach simplement.
    #
    #
    # Petit rappel pour unionfs : 
    #
    # lowerdir ; C'est le dossier contenant les fichiers "maitre" / qui ne changent jamais. ("Golden disc")
    # upperdir ; C'est le dossier qui va contenir toutes les modifications réalisés (ajout/modification/supression)
    # workdir  ; C'est le dossier tampon nécessaire à unionfs.
    # NOTE : Il peut exister plusieurs lowerdir. En cas de conflit, c'est le dernier "lowerdir" qui "gagne".

    clear

    # Passe la main à un script externe, détruit les creds par mesure de sécurité.
    FOG_islogged=0
    FOG_username=''
    FOG_password=''
    weblogin=''
    webpass=''


    # Récupère la mémoire vive disponible
    avail_mem_MB="$(LC_ALL=C free -m | grep -i "^Mem:" | awk -F" " '{print $NF}')"

    # 2 Gio de RAM ? C'est MORT. On va OOM à coup sûr !
    if (( avail_mem_MB < 2048 )); then
        export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR - OOM" \
                --timeout $FOG_DialogTimeout \
                --ok-label "OK" \
                --msgbox "Insufficient available memory to run GUI. (${avail_mem_MB} < 2 Gb)" 6 47
        export DIALOGRC=
        return 0
    fi

    # NOTE : fog.mount est hotpatchée au début de l'execution de ce script
    /bin/fog.mount 'xserver'

    # Si tout est ok, le partage est mappée (handleError sinon).
    if [[ -f '/images/!xserver/fog.xserver' ]]; then 
        # -> Le script est présent, je fait quelques calculs de sécurité...

        # Récupère la taille totale du dossier
        Xfoldersize_MB=$(du -m '/images/!xserver/' | awk '{print $1'})
        # Mémoire nécessaire = 
        #                       Taille dossier SQUASHFS                   (Car on copie le fichier en RAM)
        #                       + (Taille dossier SQUASHFS * 2)           (Espace "cache" pour l'unionFS ; squashfs décompressé ; environ 2x-4x)
        #                       + 512                                     (+ 512 Mio pour laisser un peu de place pour le système)

        RequiredMem=$((Xfoldersize_MB + (Xfoldersize_MB*2) + 512))
        FinalFreeMem=$((avail_mem_MB - RequiredMem))
        if (( FinalFreeMem > 0 )); then
            echo "Free memory ........ $FinalFreeMem M"
        else
            umount /images
            MissingMem=$((FinalFreeMem * -1))
            export DIALOGRC="/root/dialog_rouge"
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "ERROR - OOM" \
                    --timeout $FOG_DialogTimeout \
                    --ok-label "OK" \
                    --msgbox "Insufficient available memory to run GUI.\n\nRequired : $RequiredMem M\nAvailable: $avail_mem_MB M\nMissing : $MissingMem M" 9 47
            export DIALOGRC=
            return 0
        fi
        # Bon, ici on devrait être plutôt bon pour lancer le script d'init.

        # Crée un flag pour empécher une réexecution du script.
        echo "CHROOT READY" > /tmp/chroot_started
        mkdir /run/dtach >/dev/null 2>&1
        # Détruis un autre flag (recréé dans le chroot XOrg) indiquant si XOrg est prêt ou pas.
        rm /run/dtach/terminal_ready
        # Prépare le nouveau terminal à la session X
        SCRIPT=$(readlink -f $0)
        # Respawn ce script. (il patientra que /run/dtach/terminal_ready soit présent)
        dtach -n /run/dtach/fogterminal -Ez "$SCRIPT"
        
        if [[ -d '/images/!xserver' ]]; then
            # Le dossier de destination existe ? Supprime-le ! 
            rm -rf '/tmp/!xserver'
        fi
        # Copie les fichiers avec rsync
        rsync -avz --progress '/images/!xserver' '/tmp'

        # On a fini avec le répertoire source, démonte le point de montage
        umount /images

        # Prépare le script d'initialisation
        chmod +x '/tmp/!xserver/fog.xserver'

        oldpwd=$(pwd)
        . '/tmp/!xserver/fog.xserver'
        cd $oldpwd
        
        # Fin de l'exécution du script "Xorg". Je récupère la main, et si cela échoue, reviens sur un message d'erreur "panic"
        if [[ -d '/images/!xserver' ]]; then
            # Le dossier existe ? Supprime-le ! 
            rm -rf '/tmp/!xserver'
        fi        
        # Signale qu'on récupère l'exécution de FOG
        rm /tmp/chroot_started
        touch /run/dtach/terminal_ready

        dtach -a /run/dtach/fogterminal -Ez

        # Panic sync & reboot
        cd /
        sync 
        for n in /dev/sd* ; do umount $n ; done
        for n in /dev/mmc* ; do umount $n ; done

        reboot -f
    else
        export DIALOGRC="/root/dialog_jaune"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "WARNING" \
                --timeout $FOG_DialogTimeout \
                --ok-label "OK" \
                --msgbox 'File "/images/!xserver/fog.xserver" not found. Unable to start GUI' 6 47
        export DIALOGRC=
    fi
}

PROCESS_JointMulticast() {
    # Cette partie nous propose de nous connecter à une tâche multicast.
    # Varariables globales : FOG_multicastSessionName (nom de la session multicast)
    
    # Est-on connecté à FOG ? Si non, -> LOGIN
    if [[ $FOG_islogged != 1 ]]; then
        login_fog
        retval=$?
        if [[ $retval == 1 ]]; then
            # Login échouée ? AU REVOIR ! 
            return 0
        fi
    fi

    while true; do    
        # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
        verifTaches                
        verifTachesFLAG=$?
        if [[ $verifTachesFLAG == 1 ]]; then
            do_fog                # Une tâche est programmée -> je l'exécute.
        fi

        if [[ -z "$FOG_multicastSessionName" ]]; then
            # La variable n'existe pas ? Je demande le nom de la tâche multicast !
            
            BoiteDeDialogue="dialog \
            --backtitle \"$FOG_rebranding_software\" \
            --title \"Join multicast session\" 
            --insecure \
            --timeout $FOG_DialogTimeout \
            --cancel-label \"Cancel\" \
            --mixedform \
            \"Enter multicast session name :\" 10 53 0 \
            \"name:\"  1 1 \"\" 1 20 27 64 0"

            exec 3>&1
            selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
            exit_status=$?
            exec 3>&-
            if [[ $exit_status != "0" ]]; then
                FOG_multicastSessionName='' # On quitte ? PAS DE NOM !
                return 1
            fi

            IFS=$'\n'
            DUMMY=($selection)
            FOG_multicastSessionName="${DUMMY[0]}"
        fi
    
        # Réalise la query. Le fonctionnement est similaire à la programmation d'une image.
        # Dans le cas d'un PC non enregistrée ; on reçoit la tâche sous la forme d'une entrée de démarrage GRUB.
        # Dans le cas d'un PC enregistrée, la fonction verifTaches le verra (type && osid peuplée).
        DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&sessname=${FOG_multicastSessionName}&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')    
        
        verifTaches
        verifTachesFLAG=$?

        # OLD: param menuAccess 1 (si PC enregistrée)
        if [[ "$DoCurl" != *"ERRNOFOUND"* ]]; then
            if [[ $FOGcomputerName != "***Unknown***" && $verifTachesFLAG == "0" ]]; then
                export DIALOGRC="/root/dialog_rouge"
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "!!! FATAL INTERNAL ERROR !!!" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "An error occurred during the programming of the image deployment. I can't continue. -> $DoCurl" 7 47
                export DIALOGRC=
                return 0
            fi
            if [[ $FOGcomputerName == "***Unknown***" ]]; then
                # PC *PAS PRESENT* dans Fog, je dois parser les lignes pour les refiler à FOG
                
                # PASSE 1 : Récupère les infos du kernel (linuxefi ...)
                IFS=$'\n'
                for line in $DoCurl; do
                    if [[ $line == "linuxefi "* ]]; then
                        ligneKRNL=$line
                    fi
                done
                if [[ $ligneKRNL != "linuxefi "* ]]; then
                    export DIALOGRC="/root/dialog_rouge"
                    dialog \
                        --backtitle "$FOG_rebranding_software" \
                        --title "!!! FATAL INTERNAL ERROR !!!" \
                        --ok-label "Oh no !" \
                        --timeout $FOG_DialogTimeout \
                        --msgbox "I cant find the string 'linuxefi' ; I can't go on. [PROCESS_JointMulticast -> PCUnknown -> $DoCurl ]" 7 47
                    export DIALOGRC=
                    return 0
                fi
                
                # PASSE 2 : Découpe les args du kernel en infos pertinentes pour FOG
                IFS=" "
                [[ -f /tmp/krnl.txt ]] && rm /tmp/krnl.txt
                for line in $ligneKRNL; do
                    if [[ $line == *"="* ]]; then
                        cle=$(awk -F'='  '{print $1}' <<< $line)
                        valeur=$(awk -F'='  '{print $2}' <<< $line)
                        echo "[[ -z \$$cle ]] && export $cle='$valeur'" >> /tmp/krnl.txt
                    fi
                done    
                
                # Patch ridicule pour sortir les variables en EXPORT.
                # Mais cela ne fonctionne pas, car ce script (enfant) de S98MenuFog (parent) ne peut pas modifier l'environnement des parents. 
                # Donc les parents DOIVENT CHARGER les exports et si ils sont peuplés, la seulement lancer fog. (selon debug/NotDebug)
                [[ -f /tmp/krnl.txt ]] && . /tmp/krnl.txt >/dev/null 2>&1

            fi
        else
            FOG_multicastSessionName='' # Mauvais nom ; je l'efface
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR - Multicast session not found" \
                --ok-label "Ok" \
                --timeout $FOG_DialogTimeout \
                --msgbox "ERROR ; No session found with that name." 7 47
            export DIALOGRC=
        fi
            
        do_fog
    done
}

PROCESS_DeleteCurrentHost() {
    # Fonction pour supprimer l'hote actuel du serveur FOG.
    # Renvoie 1 si l'hote à été supprimée, 0 sinon.
    
    # Est-on connecté à FOG ? Si non, -> LOGIN
    if [[ $FOG_islogged != 1 ]]; then
        login_fog
        retval=$?
        if [[ $retval == 1 ]]; then
            # Login échouée ? AU REVOIR ! 
            return 0
        fi
    fi

    # Query le nom actuel du pc
    fog_compName
    
    # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
    verifTaches                
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 1 ]]; then
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi
    
    if [[ "$FOGcomputerName" != "***Unknown***" ]]; then
        exec 3>&1
        export DIALOGRC="/root/dialog_jaune"
        selection=$(dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "WARNING" \
            --defaultno \
            --timeout $FOG_DialogTimeout \
            --yesno "Would you like to delete this host ? [$FOGcomputerName]" 6 47 \
            2>&1 1>&3)
        exit_status=$?
        export DIALOGRC=
        exec 3>&-

        if [[ "$exit_status" == "0" ]]; then
            # Je supprime la machine
            # TODO FIXME : Faille de sécuritée : Il est possible de crafter une requête dans le navigateur web pour 
            #              détruire une machine du serveur FOG /!\. Confirmée avec la version DEV du 01082022

            DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&delconf=1&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')    
        
            if [[ "$DoCurl" == *"OKSUCCESS"* ]]; then
                init_backtitle        # Le nom du poste à changée. La backtitle possiblement possible. Je mets à jout tout ça.
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "Success" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "Host deleted successfully" 7 47
                    
                return 1
            else
                export DIALOGRC="/root/dialog_rouge"
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "ERROR" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "Failed to destroy Host !" 7 47
                export DIALOGRC=
                return 0
            fi
        fi
        return 0
    else
        export DIALOGRC="/root/dialog_rouge"
        dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "ERROR" \
            --ok-label "Ok" \
            --timeout $FOG_DialogTimeout \
            --msgbox "This computer doesn't exist in FOG database." 7 47
        export DIALOGRC=
        return 0
    fi
}

PROCESS_ApproveCurrentHost() {
    # Fonction pour approuver l'hote dans FOG
    # Renvoie 1 si l'hote à été approuvée, 0 sinon.
    
    # Est-on connecté à FOG ? Si non, -> LOGIN
    if [[ $FOG_islogged != 1 ]]; then
        login_fog
        retval=$?
        if [[ $retval == 1 ]]; then
            # Login échouée ? AU REVOIR ! 
            return 0
        fi
    fi

    # Query le nom actuel du pc
    fog_compName
    
    # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
    verifTaches                
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 1 ]]; then
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi
    
    if [[ "$FOGcomputerName" == "***Unknown***" ]]; then
        exec 3>&1
        export DIALOGRC="/root/dialog_jaune"
        selection=$(dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "WARNING" \
            --defaultno \
            --timeout $FOG_DialogTimeout \
            --yesno "Would you like to approve this host ?" 6 47 \
            2>&1 1>&3)
        exit_status=$?
        export DIALOGRC=
        exec 3>&-

        if [[ "$exit_status" == "0" ]]; then
            # J'approuve la machine

            DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&aprvconf=1&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')    
        
            if [[ "$DoCurl" == *"OKSUCCESS"* ]]; then
                init_backtitle        # Le nom du poste à changée. La backtitle possiblement possible. Je mets à jout tout ça.
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "Success" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "Host approved successfully" 7 47
                    
                return 1
            else
                export DIALOGRC="/root/dialog_rouge"
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "ERROR" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "Host approval failed !" 7 47
                export DIALOGRC=
                return 0
            fi
        fi
        return 0
    else
        export DIALOGRC="/root/dialog_rouge"
        dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "ERROR" \
            --ok-label "Ok" \
            --timeout $FOG_DialogTimeout \
            --msgbox "This computer exist in FOG database." 7 47
        export DIALOGRC=
        return 0
    fi   
}

PROCESS_UpdateKey() {
    # Cette partie met à jour la clé produit
    # Varariables globales : FOG_multicastSessionName (nom de la session multicast)
      
    # Est-on connecté à FOG ? Si non, -> LOGIN
    if [[ $FOG_islogged != 1 ]]; then
        login_fog
        retval=$?
        if [[ $retval == 1 ]]; then
            # Login échouée ? AU REVOIR ! 
            return 0
        fi
    fi

    # Vérifie que le serveur FOG nous a pas donnés une tâche . . .
    verifTaches                
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 1 ]]; then
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi

    if [[ $FOGcomputerName != "***Unknown***" ]]; then

        BoiteDeDialogue="dialog \
        --backtitle \"$FOG_rebranding_software\" \
        --title \"Update Product Key\" 
        --insecure \
        --timeout $FOG_DialogTimeout \
        --cancel-label \"Cancel\" \
        --mixedform \
        \"Please enter the product key :\" 10 53 0 \
        \"Key:\"  1 1 \"\" 1 10 37 64 0"

        exec 3>&1
        selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
        exit_status=$?
        exec 3>&-
        if [[ $exit_status != "0" ]]; then
            FOG_prodkey='' # On quitte ? PAS DE NOM !
            return 1
        fi

        IFS=$'\n'
        DUMMY=($selection)
        FOG_prodkey="${DUMMY[0]}"
    
        # Réalise la query. Le fonctionnement est similaire à la programmation d'une image.
        # Dans le cas d'un PC non enregistrée ; on reçoit la tâche sous la forme d'une entrée de démarrage GRUB.
        # Dans le cas d'un PC enregistrée, la fonction verifTaches le verra (type && osid peuplée).

        DoCurl=$(curl -Lks --data "sysuuid=${MONuuid}&mac=$MONmac&key=${FOG_prodkey}&username=${FOG_username}&password=${FOG_password}" "${web}service/grub/grub.php" -A '')    
        
        verifTaches
        verifTachesFLAG=$?

        if [[ "$DoCurl" == *"OKSUCCESS"* ]]; then
                dialog \
                    --backtitle "$FOG_rebranding_software" \
                    --title "Success" \
                    --ok-label "Ok" \
                    --timeout $FOG_DialogTimeout \
                    --msgbox "Successfully changed key" 7 47
        else
            FOG_prodkey='' # Mauvaise clé, je l'efface
            export DIALOGRC="/root/dialog_rouge"
            dialog \
                --backtitle "$FOG_rebranding_software" \
                --title "ERROR" \
                --ok-label "Ok" \
                --timeout $FOG_DialogTimeout \
                --msgbox "ERROR ; Unable to change key !" 7 47
            export DIALOGRC=
        fi  
    else
        FOG_prodkey=''
        export DIALOGRC="/root/dialog_rouge"
        dialog \
            --backtitle "$FOG_rebranding_software" \
            --title "ERROR" \
            --ok-label "Ok" \
            --timeout $FOG_DialogTimeout \
            --msgbox "This computer doesn't exist in FOG database." 7 47
        export DIALOGRC=
    fi
}

# Hotpach le système FOG (permettant de récupérer les exports + tard)
hotpatch_fog

# Si la variable n'est pas initialisée, le reste du script peut crasher (TODO : nettoyer le script pour que cela n'arrive pas)
FOG_islogged=0
# On ne relance pas FOG à la fin de la tâche.
relaunchFog=0
# Configure le temps (en secondes) avant le timeout d'un élément du menu (défaut : 900 secondes / 15 minutes)
[[ -z $FOG_DialogTimeout ]] && FOG_DialogTimeout=900
[[ -n $keymap ]] && loadkeys $keymap


MONuuid=$(dmidecode -s system-uuid)
MONuuid=${sysuuid,,}
MONmac=$(getMACAddresses)

# Récupère le nom de l'ordinateur dans la BDD Fog pour un titre + joli...
init_backtitle

# MOD Xorg ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if [[ -n "${gfxgui}" ]]; then # Si la variable existe...
    if [[ ! -f "/tmp/chroot_started" ]]; then # Et que l'on a pas déjà ouvert un chroot...
        if [[ ! -f "/run/dtach/fogterminal" ]]; then # ... et que la session dtach n'est pas lancée
            if [[ "$gfxgui" = "xorg" ]]; then # Et que la variable = xorg, alors on spawn un XOrg.
                # TODO : A refaire ( AVEC authentification)
                PROCESS_XOrg
                do_exit
            fi
        fi
    fi
fi
if [[ -f "/tmp/chroot_started" ]]; then # Si le chroot est ouvert...
    if [[ ! -f "/run/dtach/terminal_ready" ]]; then # ...mais le drapeau n'est pas encore présent...
        trap '' 2 # Désactive le Ctrl+C
        while [[ ! -f "/run/dtach/terminal_ready" ]] # Je boucle tant que le drapeau n'est pas là.
        do
            sleep 1
            echo "Please wait while terminal loading is complete."
        done
        clear
        echo "Please wait..."
        sleep 2
        # A ce niveau, le terminal est prêt. On continue le script...
    fi
fi
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if [[ -n "${menutype}" ]]; then       
    case $menutype in
        memtester)
            PROCESS_Memtest
            do_exit
            ;;
        down)
            login_or_reboot
            PROCESS_SelectDownloadImage
            ;;
        askmc)
            login_or_reboot
            PROCESS_JointMulticast
            ;;
        unreg)
            login_or_reboot
            PROCESS_DeleteCurrentHost
            ;;
        approvehost)
            login_or_reboot
            PROCESS_ApproveCurrentHost
            ;;
        updatekey)
            login_or_reboot
            PROCESS_UpdateKey
            ;;
        *)
            #[[ -z $type ]] && type="Null"
            #handleError "Fatal Error: Unknown request type :: $type"
            ;;
    esac    
fi
    

    


while true; do
    fog_compName
    verifTaches
    verifTachesFLAG=$?
    if [[ $verifTachesFLAG == 0 ]]; then       
        DIALOG_CANCEL=1
        DIALOG_ESC=255

        BoiteDeDialogue="dialog \
            --backtitle \"$FOG_rebranding_software\" \
            --title \"Main menu\" \
            --clear \
            --timeout $FOG_DialogTimeout \
            --cancel-label \"Reboot\" \
            --menu \"\" 0 0 10 \
            \"1\" \"Reboot\" \
            \"\" \"--------------------------\" \
            $([[ $FOGcomputerName == "***Unknown***" ]] && echo "\"2\" \"Perform Full Host Registration and Inventory\"") \
            $([[ $FOGcomputerName == "***Unknown***" ]] && echo "\"3\" \"Quick registration and Inventory\"") \
            \"4\" \"Deploy Image\" \
            \"5\" \"Run Memtester\" \
            \"6\" \"Join Multicast session\" \
            $([[ $FOGcomputerName != "***Unknown***" ]] && echo "\"7\" \"Quick host deletion\"") \
            $([[ $FOGcomputerName != "***Unknown***" ]] && echo "\"8\" \"Update product key\"") \
            $([[ ! -f '/run/dtach/terminal_ready' ]] && echo "\"9\" \"Enable GUI\"")"
        exec 3>&1
        selection=$(eval $BoiteDeDialogue 2>&1 1>&3)
        exit_status=$?
        exec 3>&-

        case $exit_status in
            $DIALOG_CANCEL)
                do_exit
                ;;
            $DIALOG_ESC)
                do_exit
                ;;
        esac
          
          
        case $selection in
            0 ) # ===== NO Selection
                do_exit
                ;;
            1 ) # ===== Reboot
                do_exit
                ;;
            2 ) # ===== manreg
                clear
                export mode="manreg"
                fog
                export -n mode
                export -n type
                fog_compName
                init_backtitle
                ;;
            3 ) # ===== autoreg
                clear
                export mode="autoreg"
                fog
                export -n mode
                export -n type
                fog_compName
                init_backtitle
                ;;
            4 )
                # ===== deploy_image
                PROCESS_SelectDownloadImage
                export -n mode
                export -n type
                ;;
            5 ) # ===== Run Memtester
                PROCESS_Memtest
                do_exit
                ;;    
            6 ) # ===== Join Multicast session
                PROCESS_JointMulticast
                ;;
            7 ) # ===== Delete current host 
                PROCESS_DeleteCurrentHost
                ;;
            8 ) # ===== Update product key
                PROCESS_UpdateKey
                ;;
            9 ) # ===== Enable GUI
                if [[ ! -f "/tmp/chroot_started" ]]; then # Si on a pas déjà ouvert un chroot...
                    if [[ ! -f '/run/dtach/terminal_ready' ]]; then #... et qu'on est pas dans un terminal dtach
                        # Est-on connecté à FOG ? Si non, -> LOGIN
                        if [[ $FOG_islogged != 1 ]]; then
                            login_fog
                            retval=$?
                        fi
                        if [[ $FOG_islogged != 0 ]]; then
                            PROCESS_XOrg
                            do_exit
                        fi
                    else
                        # Echoue avec un message d'erreur générique
                        export DIALOGRC="/root/dialog_jaune"
                            dialog \
                                --backtitle "$FOG_rebranding_software" \
                                --title "WARNING" \
                                --timeout $FOG_DialogTimeout \
                                --ok-label "OK" \
                                --msgbox "Dtach subterminal is already active." 6 47
                        export DIALOGRC= 
                    fi
                else
                    export DIALOGRC="/root/dialog_jaune"
                        dialog \
                            --backtitle "$FOG_rebranding_software" \
                            --title "WARNING" \
                            --timeout $FOG_DialogTimeout \
                            --ok-label "OK" \
                            --msgbox "The GUI is already active." 6 47
                    export DIALOGRC=
                fi
                ;;
        esac
    else
        do_fog                # Une tâche est programmée -> je l'exécute.
    fi

    mode=""
    type=""
done
